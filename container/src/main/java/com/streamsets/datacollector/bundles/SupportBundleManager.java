/**
 * Copyright 2017 StreamSets Inc.
 *
 * Licensed under the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.streamsets.datacollector.bundles;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.streamsets.datacollector.main.BuildInfo;
import com.streamsets.datacollector.main.RuntimeInfo;
import com.streamsets.pipeline.lib.executor.SafeScheduledExecutorService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.inject.Inject;
import javax.inject.Named;
import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.PipedInputStream;
import java.io.PipedOutputStream;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.concurrent.ExecutorService;
import java.util.stream.Collectors;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

/**
 * Main manager that is taking care of bundle creation.
 */
public class SupportBundleManager implements BundleContext {

  private static final Logger LOG = LoggerFactory.getLogger(SupportBundleManager.class);

  /**
   * Executor service for generating new bundles.
   *
   * They are generated by a different thread and piped out via generateNewBundle() call.
   */
  private final ExecutorService executor;

  private final RuntimeInfo runtimeInfo;
  private final BuildInfo buildInfo;

  /**
   * List describing auto discovered content generators.
   */
  private List<BundleContentGeneratorDefinition> definitions;

  @Inject
  public SupportBundleManager(
    @Named("supportBundleExecutor") SafeScheduledExecutorService executor,
    RuntimeInfo runtimeInfo,
    BuildInfo buildInfo
  ) {
    this.executor = executor;
    this.runtimeInfo = runtimeInfo;
    this.buildInfo = buildInfo;

    ImmutableList.Builder builder = new ImmutableList.Builder();
    try {
      InputStream generatorResource = Thread.currentThread().getContextClassLoader().getResourceAsStream(SupportBundleContentGeneratorProcessor.RESOURCE_NAME);
      BufferedReader reader = new BufferedReader(new InputStreamReader(generatorResource));
      String className;
      while((className = reader.readLine()) != null) {
        Class<? extends BundleContentGenerator> bundleClass = (Class<? extends BundleContentGenerator>) Class.forName(className);

        BundleContentGeneratorDef def = bundleClass.getAnnotation(BundleContentGeneratorDef.class);
        if(def == null) {
          LOG.error("Bundle creator class {} is missing required annotation", bundleClass.getName());
          continue;
        }

        builder.add(new BundleContentGeneratorDefinition(
          bundleClass,
          def.name(),
          def.description(),
          def.version(),
          def.enabledByDefault()
        ));
      }
    } catch (Exception e) {
      LOG.error("Was not able to initialize support bundle generator classes.", e);
    }

    definitions = builder.build();
  }

  /**
   * Returns immutable list with metadata of registered content generators.
   */
  public List<BundleContentGeneratorDefinition> getContentDefinitions() {
    return definitions;
  }

  /**
   * Return InputStream from which a new generated resource bundle can be retrieved.
   */
  public InputStream generateNewBundle(List<String> generators) throws IOException {
    PipedInputStream inputStream = new PipedInputStream();
    PipedOutputStream outputStream = new PipedOutputStream();
    inputStream.connect(outputStream);
    ZipOutputStream zipOutputStream = new ZipOutputStream(outputStream);

    List<BundleContentGeneratorDefinition> useDefs = getRequestedDefinitions(generators);
    executor.submit(() -> generateNewBundleInternal(useDefs, zipOutputStream));

    return inputStream;
  }

  /**
   * Orchestrate what definitions should be used for this bundle.
   *
   * Either get all definittions that should be used by default or only those specified in the generators argument.
   */
  private List<BundleContentGeneratorDefinition> getRequestedDefinitions(List<String> generators) {
    List<BundleContentGeneratorDefinition> useDefs;
    if(generators == null || generators.isEmpty()) {
      // Filter out default generators
      useDefs = definitions.stream()
        .filter(BundleContentGeneratorDefinition::isEnabledByDefault)
        .collect(Collectors.toList());
    } else {
      useDefs = definitions.stream()
        .filter(def -> generators.contains(def.getKlass().getName()))
        .collect(Collectors.toList());
    }
    return useDefs;
  }

  private void generateNewBundleInternal(List<BundleContentGeneratorDefinition> defs, ZipOutputStream zipStream) {
    try {
      Properties generators = new Properties();

      // Let each individual content generator run to generate it's content
      for(BundleContentGeneratorDefinition definition : defs) {
        BundleWriter writer = new BundleWriterImpl(definition.getKlass().getName(), zipStream);
        BundleContentGenerator contentGenerator = definition.getKlass().newInstance();

        contentGenerator.generateContent(this, writer);
        generators.put(definition.getKlass().getName(), String.valueOf(definition.getVersion()));
      }

      // generators.properties
      zipStream.putNextEntry(new ZipEntry("generators.properties"));
      generators.store(zipStream, "");
      zipStream.closeEntry();

      // metadata.properties
      Properties metadata = new Properties();
      metadata.put("version", "1");
      metadata.put("sdc.version", buildInfo.getVersion());
      metadata.put("sdc.id", runtimeInfo.getId());
      metadata.put("sdc.acl.enabled", String.valueOf(runtimeInfo.isAclEnabled()));

      zipStream.putNextEntry(new ZipEntry("metadata.properties"));
      metadata.store(zipStream, "");
      zipStream.closeEntry();

    } catch (Exception e) {
      LOG.error("Failed to generate resource bundle", e);
    } finally {
      // And that's it
      try {
        zipStream.close();
      } catch (IOException e) {
        LOG.error("Failed to finish generating the bundle", e);
      }
    }
  }

  @Override
  public BuildInfo getBuildInfo() {
    return buildInfo;
  }

  @Override
  public RuntimeInfo getRuntimeInfo() {
    return runtimeInfo;
  }

  private static class BundleWriterImpl extends BundleWriter {

    private final String prefix;
    private final ZipOutputStream zipOutputStream;

    public BundleWriterImpl(
      String prefix,
      ZipOutputStream outputStream
    ) {
      this.prefix = prefix + File.separator;
      this.zipOutputStream = outputStream;
    }

    @Override
    public void markStartOfFile(String name) throws IOException {
      zipOutputStream.putNextEntry(new ZipEntry(prefix + name));
    }

    @Override
    public void markEndOfFile() throws IOException {
      zipOutputStream.closeEntry();
    }

    @Override
    public void write(int b) throws IOException {
      zipOutputStream.write(b);
    }
  }
}
